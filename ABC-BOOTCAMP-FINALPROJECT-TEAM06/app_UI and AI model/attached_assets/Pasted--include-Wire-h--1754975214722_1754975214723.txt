// ë§ˆì´í¬ + ì§„ë™ í•˜ì´ë¸Œë¦¬ë“œ ê°ì§€ ì‹œìŠ¤í…œ
// ìŒì„±ê³¼ ì§„ë™ì„ ë™ì‹œì— ê°ì§€í•˜ëŠ” í†µí•© ì‹œìŠ¤í…œ

#include <Wire.h>

// ========== í•€ ì„¤ì • ==========
// ë§ˆì´í¬ ì„¼ì„œ
const int MIC_ANALOG_PIN = A0;
const int MIC_DIGITAL_PIN = 2;

// GY-521 ì§„ë™ ì„¼ì„œ (I2C)
const int MPU_ADDR = 0x68;
const int PWR_MGMT_1 = 0x6B;
const int ACCEL_XOUT_H = 0x3B;

// LED ì¶œë ¥
const int LED_MIC_DETECTED = 8;      // ë§ˆì´í¬ ê°ì§€ (ë¹¨ê°„ìƒ‰)
const int LED_VIBRATION_DETECTED = 9; // ì§„ë™ ê°ì§€ (íŒŒë€ìƒ‰)
const int LED_SPEAKING = 10;         // ë§í•˜ëŠ” ì¤‘ (ë…¹ìƒ‰)
const int LED_CONTINUOUS_VIB = 11;   // ì§€ì†ì  ì§„ë™ (ë…¸ë€ìƒ‰)
const int BUZZER_PIN = 12;           // ì•Œë¦¼ ë¶€ì €

// ========== ê°ì§€ ì„¤ì • ==========
const int SAMPLE_SIZE = 80;
const int SAMPLING_DELAY = 60;

// ë§ˆì´í¬ ì„ê³„ê°’
float VOICE_AMPLITUDE_MIN = 25;
float VOICE_AMPLITUDE_MAX = 350;
const float VOICE_CONFIDENCE_THRESHOLD = 0.6;

// ì§„ë™ ì„ê³„ê°’
const float LIGHT_VIBRATION_THRESHOLD = 1.5;
const float STRONG_VIBRATION_THRESHOLD = 4.0;
const float SHOCK_THRESHOLD = 8.0;

// ========== ì „ì—­ ë³€ìˆ˜ ==========
// ë§ˆì´í¬ ê´€ë ¨
int backgroundLevel = 512;
unsigned long lastVoiceTime = 0;
unsigned long voiceStartTime = 0;
bool isSpeaking = false;
const int VOICE_HISTORY_SIZE = 12;
bool voiceHistory[VOICE_HISTORY_SIZE] = {false};
int voiceHistoryIndex = 0;

// ì§„ë™ ê´€ë ¨
float baselineX = 0, baselineY = 0, baselineZ = 0;
bool vibrationCalibrated = false;
unsigned long lastVibrationTime = 0;
unsigned long vibrationStartTime = 0;
bool isContinuousVibration = false;
const int VIB_HISTORY_SIZE = 10;
float vibrationHistory[VIB_HISTORY_SIZE] = {0};
int vibrationHistoryIndex = 0;

// ì‹œìŠ¤í…œ ìƒíƒœ
bool micInitialized = false;
bool gyroInitialized = false;
int audioSamples[SAMPLE_SIZE];

// ========== êµ¬ì¡°ì²´ ì •ì˜ ==========
struct VoiceFeatures {
  float amplitude;
  float variation;
  float consistency;
  float confidence;
};

struct VibrationFeatures {
  float intensity;
  float type; // 0=none, 1=light, 2=strong, 3=shock
  bool isContinuous;
};

enum DetectionType {
  NOTHING,
  VOICE_ONLY,
  VIBRATION_ONLY,
  BOTH_DETECTED
};

void setup() {
  Serial.begin(115200);
  Wire.begin();
  
  // í•€ ì´ˆê¸°í™”
  pinMode(MIC_DIGITAL_PIN, INPUT);
  pinMode(LED_MIC_DETECTED, OUTPUT);
  pinMode(LED_VIBRATION_DETECTED, OUTPUT);
  pinMode(LED_SPEAKING, OUTPUT);
  pinMode(LED_CONTINUOUS_VIB, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  
  Serial.println("=== í•˜ì´ë¸Œë¦¬ë“œ ê°ì§€ ì‹œìŠ¤í…œ ===");
  Serial.println("ğŸ¤ ë§ˆì´í¬ ì„¼ì„œ + ğŸ”” ì§„ë™ ì„¼ì„œ");
  Serial.println("ğŸ”´ 8ë²ˆ LED: ë§ˆì´í¬ ê°ì§€");
  Serial.println("ğŸ”µ 9ë²ˆ LED: ì§„ë™ ê°ì§€");
  Serial.println("ğŸŸ¢ 10ë²ˆ LED: ë§í•˜ëŠ” ì¤‘");
  Serial.println("ğŸŸ¡ 11ë²ˆ LED: ì§€ì†ì  ì§„ë™");
  
  // LED í…ŒìŠ¤íŠ¸
  testAllLEDs();
  
  // ì„¼ì„œ ì´ˆê¸°í™”
  initializeSensors();
  
  Serial.println("ğŸ¯ í•˜ì´ë¸Œë¦¬ë“œ ê°ì§€ ì‹œì‘!");
  delay(1000);
}

void loop() {
  // ë‘ ì„¼ì„œì—ì„œ ë°ì´í„° ìˆ˜ì§‘
  VoiceFeatures voice = {0};
  VibrationFeatures vibration = {0};
  
  bool voiceValid = false;
  bool vibrationValid = false;
  
  // ë§ˆì´í¬ ë¶„ì„
  if(micInitialized) {
    sampleAudio();
    voice = analyzeVoice();
    voiceValid = true;
  }
  
  // ì§„ë™ ë¶„ì„  
  if(gyroInitialized) {
    vibration = analyzeVibration();
    vibrationValid = true;
  }
  
  // í†µí•© ê°ì§€ ë¡œì§
  DetectionType detection = integratedDetection(voice, vibration, voiceValid, vibrationValid);
  
  // í™œë™ ì¶”ì  ì—…ë°ì´íŠ¸
  updateActivities(voice, vibration, detection);
  
  // ì¶œë ¥ ì œì–´
  controlAllOutputs(detection, voice, vibration);
  
  // ê²°ê³¼ ì¶œë ¥
  printIntegratedAnalysis(voice, vibration, detection, voiceValid, vibrationValid);
  
  delay(70); // 70ms ê°„ê²©
}

void initializeSensors() {
  Serial.println("\nğŸ”§ ì„¼ì„œ ì´ˆê¸°í™” ì¤‘...");
  
  // ë§ˆì´í¬ ì´ˆê¸°í™”
  Serial.print("ğŸ¤ ë§ˆì´í¬ ì„¼ì„œ... ");
  micInitialized = initializeMicrophone();
  if(micInitialized) {
    Serial.println("âœ… ì„±ê³µ");
  } else {
    Serial.println("âŒ ì‹¤íŒ¨");
  }
  
  // ì§„ë™ ì„¼ì„œ ì´ˆê¸°í™”
  Serial.print("ğŸ”” ì§„ë™ ì„¼ì„œ... ");
  gyroInitialized = initializeGyro();
  if(gyroInitialized) {
    Serial.println("âœ… ì„±ê³µ");
    calibrateVibrationBaseline();
  } else {
    Serial.println("âŒ ì‹¤íŒ¨ (ì—°ê²° í™•ì¸ í•„ìš”)");
  }
  
  if(!micInitialized && !gyroInitialized) {
    Serial.println("âš ï¸ ëª¨ë“  ì„¼ì„œ ì´ˆê¸°í™” ì‹¤íŒ¨!");
  }
}

bool initializeMicrophone() {
  // ë§ˆì´í¬ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
  long sum = 0;
  int samples = 30;
  
  for(int i = 0; i < samples; i++) {
    sum += analogRead(MIC_ANALOG_PIN);
    delay(50);
  }
  
  backgroundLevel = sum / samples;
  
  // ê°ë„ ìë™ ì¡°ì •
  int noise = 0;
  for(int i = 0; i < 20; i++) {
    int val1 = analogRead(MIC_ANALOG_PIN);
    delay(10);
    int val2 = analogRead(MIC_ANALOG_PIN);
    noise += abs(val2 - val1);
    delay(10);
  }
  noise = noise / 20;
  
  VOICE_AMPLITUDE_MIN = max(20.0, noise * 1.2);
  VOICE_AMPLITUDE_MAX = min(400.0, noise * 6.0);
  
  Serial.print("(ë°°ê²½: ");
  Serial.print(backgroundLevel);
  Serial.print(", ì„ê³„ê°’: ");
  Serial.print(VOICE_AMPLITUDE_MIN, 0);
  Serial.print("-");
  Serial.print(VOICE_AMPLITUDE_MAX, 0);
  Serial.print(") ");
  
  return true; // ë§ˆì´í¬ëŠ” í•­ìƒ ì‚¬ìš© ê°€ëŠ¥
}

bool initializeGyro() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(PWR_MGMT_1);
  Wire.write(0);
  int result = Wire.endTransmission();
  
  if(result != 0) return false;
  
  delay(100);
  
  // WHO_AM_I í™•ì¸
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x75);
  Wire.endTransmission();
  Wire.requestFrom(MPU_ADDR, 1);
  
  if(Wire.available()) {
    int whoAmI = Wire.read();
    return (whoAmI == 0x68);
  }
  
  return false;
}

void calibrateVibrationBaseline() {
  Serial.print("ì§„ë™ ê¸°ì¤€ê°’ ì¸¡ì • ì¤‘... ");
  
  float sumX = 0, sumY = 0, sumZ = 0;
  int samples = 30;
  int successCount = 0;
  
  for(int i = 0; i < samples; i++) {
    float x, y, z;
    if(readAcceleration(x, y, z)) {
      sumX += x;
      sumY += y;
      sumZ += z;
      successCount++;
    }
    delay(50);
  }
  
  if(successCount > 0) {
    baselineX = sumX / successCount;
    baselineY = sumY / successCount;
    baselineZ = sumZ / successCount;
    vibrationCalibrated = true;
    
    Serial.print("ì™„ë£Œ (");
    Serial.print(baselineX, 2);
    Serial.print(", ");
    Serial.print(baselineY, 2);
    Serial.print(", ");
    Serial.print(baselineZ, 2);
    Serial.print(")");
  }
}

void sampleAudio() {
  for(int i = 0; i < SAMPLE_SIZE; i++) {
    audioSamples[i] = analogRead(MIC_ANALOG_PIN);
    delayMicroseconds(SAMPLING_DELAY);
  }
}

VoiceFeatures analyzeVoice() {
  VoiceFeatures voice;
  
  // ê¸°ë³¸ í†µê³„
  long sum = 0;
  int maxVal = 0, minVal = 1023;
  
  for(int i = 0; i < SAMPLE_SIZE; i++) {
    sum += audioSamples[i];
    if(audioSamples[i] > maxVal) maxVal = audioSamples[i];
    if(audioSamples[i] < minVal) minVal = audioSamples[i];
  }
  
  float average = sum / (float)SAMPLE_SIZE;
  voice.amplitude = maxVal - minVal;
  
  // ë³€í™”ëŸ‰ ê³„ì‚°
  int changes = 0;
  for(int i = 1; i < SAMPLE_SIZE; i++) {
    if(abs(audioSamples[i] - audioSamples[i-1]) > 8) {
      changes++;
    }
  }
  voice.variation = (float)changes / SAMPLE_SIZE;
  
  // ì¼ê´€ì„± ê³„ì‚°
  float threshold = average + (voice.amplitude * 0.15);
  int consistent = 0;
  for(int i = 0; i < SAMPLE_SIZE; i++) {
    if(abs(audioSamples[i] - average) > threshold) {
      consistent++;
    }
  }
  voice.consistency = (float)consistent / SAMPLE_SIZE;
  
  // ì‹ ë¢°ë„ ê³„ì‚°
  voice.confidence = 0;
  if(voice.amplitude > VOICE_AMPLITUDE_MIN && voice.amplitude < VOICE_AMPLITUDE_MAX) {
    voice.confidence += 0.4;
  }
  if(voice.variation > 0.15 && voice.variation < 0.7) {
    voice.confidence += 0.3;
  }
  if(voice.consistency > 0.25) {
    voice.confidence += 0.3;
  }
  
  return voice;
}

VibrationFeatures analyzeVibration() {
  VibrationFeatures vib = {0, 0, false};
  
  if(!vibrationCalibrated) return vib;
  
  float x, y, z;
  if(!readAcceleration(x, y, z)) return vib;
  
  // ì§„ë™ ê°•ë„ ê³„ì‚°
  float deltaX = x - baselineX;
  float deltaY = y - baselineY;
  float deltaZ = z - baselineZ;
  
  vib.intensity = sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);
  
  // ì§„ë™ íƒ€ì… ë¶„ë¥˜
  if(vib.intensity > SHOCK_THRESHOLD) {
    vib.type = 3; // ì¶©ê²©
  } else if(vib.intensity > STRONG_VIBRATION_THRESHOLD) {
    vib.type = 2; // ê°•í•œ ì§„ë™
  } else if(vib.intensity > LIGHT_VIBRATION_THRESHOLD) {
    vib.type = 1; // ê°€ë²¼ìš´ ì§„ë™
  } else {
    vib.type = 0; // ì§„ë™ ì—†ìŒ
  }
  
  // ì§€ì†ì„± í™•ì¸
  updateVibrationHistory(vib.intensity);
  float avgVibration = calculateAverageVibration();
  vib.isContinuous = (avgVibration > LIGHT_VIBRATION_THRESHOLD);
  
  return vib;
}

bool readAcceleration(float &x, float &y, float &z) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(ACCEL_XOUT_H);
  Wire.endTransmission();
  Wire.requestFrom(MPU_ADDR, 6);
  
  if(Wire.available() >= 6) {
    int16_t rawX = (Wire.read() << 8) | Wire.read();
    int16_t rawY = (Wire.read() << 8) | Wire.read();
    int16_t rawZ = (Wire.read() << 8) | Wire.read();
    
    x = rawX / 16384.0;
    y = rawY / 16384.0;
    z = rawZ / 16384.0;
    
    return true;
  }
  
  return false;
}

DetectionType integratedDetection(VoiceFeatures voice, VibrationFeatures vib, bool voiceValid, bool vibValid) {
  bool voiceDetected = false;
  bool vibrationDetected = false;
  
  // ìŒì„± ê°ì§€
  if(voiceValid && voice.confidence > VOICE_CONFIDENCE_THRESHOLD) {
    if(voice.amplitude > 15 && voice.variation > 0.1 && voice.variation < 0.8) {
      voiceDetected = true;
    }
  }
  
  // ì§„ë™ ê°ì§€
  if(vibValid && vib.type > 0) {
    vibrationDetected = true;
  }
  
  // í†µí•© íŒì •
  if(voiceDetected && vibrationDetected) {
    return BOTH_DETECTED;
  } else if(voiceDetected) {
    return VOICE_ONLY;
  } else if(vibrationDetected) {
    return VIBRATION_ONLY;
  } else {
    return NOTHING;
  }
}

void updateActivities(VoiceFeatures voice, VibrationFeatures vib, DetectionType detection) {
  unsigned long currentTime = millis();
  
  // ìŒì„± í™œë™ ì¶”ì 
  bool currentVoice = (detection == VOICE_ONLY || detection == BOTH_DETECTED);
  voiceHistory[voiceHistoryIndex] = currentVoice;
  voiceHistoryIndex = (voiceHistoryIndex + 1) % VOICE_HISTORY_SIZE;
  
  int voiceCount = 0;
  for(int i = 0; i < VOICE_HISTORY_SIZE; i++) {
    if(voiceHistory[i]) voiceCount++;
  }
  
  // ë§í•˜ê¸° ì‹œì‘/ë ê°ì§€
  if(!isSpeaking && voiceCount >= 4) {
    isSpeaking = true;
    voiceStartTime = currentTime;
    Serial.println("ğŸ¤ ë§í•˜ê¸° ì‹œì‘!");
    tone(BUZZER_PIN, 1200, 150);
  }
  
  if(isSpeaking && voiceCount <= 1) {
    isSpeaking = false;
    Serial.print("ğŸ”‡ ë§í•˜ê¸° ì¢…ë£Œ (");
    Serial.print(currentTime - voiceStartTime);
    Serial.println("ms)");
    tone(BUZZER_PIN, 800, 100);
  }
  
  if(currentVoice) {
    lastVoiceTime = currentTime;
  }
  
  // ì§„ë™ í™œë™ ì¶”ì 
  bool currentVibration = (detection == VIBRATION_ONLY || detection == BOTH_DETECTED);
  
  if(!isContinuousVibration && vib.isContinuous) {
    isContinuousVibration = true;
    vibrationStartTime = currentTime;
    Serial.println("ğŸ”” ì§€ì†ì  ì§„ë™ ì‹œì‘!");
  }
  
  if(isContinuousVibration && !vib.isContinuous) {
    isContinuousVibration = false;
    Serial.print("âšª ì§„ë™ ì¢…ë£Œ (");
    Serial.print(currentTime - vibrationStartTime);
    Serial.println("ms)");
  }
  
  if(currentVibration) {
    lastVibrationTime = currentTime;
    
    // ì¶©ê²© ê°ì§€ì‹œ íŠ¹ë³„ ì•Œë¦¼
    if(vib.type == 3) {
      tone(BUZZER_PIN, 2000, 200);
      delay(100);
      tone(BUZZER_PIN, 2000, 200);
    }
  }
}

void controlAllOutputs(DetectionType detection, VoiceFeatures voice, VibrationFeatures vib) {
  unsigned long currentTime = millis();
  
  // ëª¨ë“  LED ì´ˆê¸°í™”
  digitalWrite(LED_MIC_DETECTED, LOW);
  digitalWrite(LED_VIBRATION_DETECTED, LOW);
  digitalWrite(LED_SPEAKING, LOW);
  digitalWrite(LED_CONTINUOUS_VIB, LOW);
  
  // ë§ˆì´í¬ LED (8ë²ˆí•€)
  if(currentTime - lastVoiceTime < 500) {
    digitalWrite(LED_MIC_DETECTED, HIGH);
  }
  
  // ì§„ë™ LED (9ë²ˆí•€)
  if(currentTime - lastVibrationTime < 300) {
    digitalWrite(LED_VIBRATION_DETECTED, HIGH);
  }
  
  // ë§í•˜ëŠ” ì¤‘ LED (10ë²ˆí•€)
  if(isSpeaking) {
    digitalWrite(LED_SPEAKING, HIGH);
  }
  
  // ì§€ì†ì  ì§„ë™ LED (11ë²ˆí•€)
  if(isContinuousVibration) {
    digitalWrite(LED_CONTINUOUS_VIB, HIGH);
  }
}

void printIntegratedAnalysis(VoiceFeatures voice, VibrationFeatures vib, DetectionType detection, bool voiceValid, bool vibValid) {
  Serial.print("ğŸ¯ í†µí•©ë¶„ì„ - ");
  
  if(voiceValid) {
    Serial.print("ğŸ¤ì§„í­:");
    Serial.print(voice.amplitude, 0);
    Serial.print("/ì‹ ë¢°:");
    Serial.print(voice.confidence, 2);
  } else {
    Serial.print("ğŸ¤âŒ");
  }
  
  Serial.print(" | ");
  
  if(vibValid) {
    Serial.print("ğŸ””ê°•ë„:");
    Serial.print(vib.intensity, 2);
    Serial.print("/íƒ€ì…:");
    Serial.print(vib.type, 0);
  } else {
    Serial.print("ğŸ””âŒ");
  }
  
  Serial.print(" -> ");
  
  switch(detection) {
    case VOICE_ONLY:
      Serial.println("ğŸ”´ ìŒì„± ê°ì§€!");
      break;
    case VIBRATION_ONLY:
      Serial.print("ğŸ”µ ì§„ë™ ê°ì§€");
      if(vib.type == 3) Serial.println(" (ì¶©ê²©!)");
      else if(vib.type == 2) Serial.println(" (ê°•í•¨)");
      else Serial.println(" (ê°€ë²¼ì›€)");
      break;
    case BOTH_DETECTED:
      Serial.println("ğŸŸ£ ìŒì„±+ì§„ë™ ë™ì‹œ ê°ì§€!");
      break;
    default:
      Serial.println("âšª ê°ì§€ ì—†ìŒ");
      break;
  }
}

void updateVibrationHistory(float intensity) {
  vibrationHistory[vibrationHistoryIndex] = intensity;
  vibrationHistoryIndex = (vibrationHistoryIndex + 1) % VIB_HISTORY_SIZE;
}

float calculateAverageVibration() {
  float sum = 0;
  for(int i = 0; i < VIB_HISTORY_SIZE; i++) {
    sum += vibrationHistory[i];
  }
  return sum / VIB_HISTORY_SIZE;
}

void testAllLEDs() {
  Serial.println("LED í…ŒìŠ¤íŠ¸...");
  
  int leds[] = {LED_MIC_DETECTED, LED_VIBRATION_DETECTED, LED_SPEAKING, LED_CONTINUOUS_VIB};
  String names[] = {"ë§ˆì´í¬", "ì§„ë™", "ë§í•˜ëŠ”ì¤‘", "ì§€ì†ì§„ë™"};
  
  for(int i = 0; i < 4; i++) {
    Serial.print(names[i]);
    Serial.print(" ");
    digitalWrite(leds[i], HIGH);
    delay(400);
    digitalWrite(leds[i], LOW);
    delay(200);
  }
  
  tone(BUZZER_PIN, 1000, 200);
  delay(300);
  
  Serial.println("ì™„ë£Œ");
}